---
stories:
  "/Users/macbookpro/hero/tips/src/144641364200.md": !ruby/object:CliTasks::Note
    data: |+
      favor hardlinks over symlinks, when possible.  for example, a symlink can break
      for any number of reasons, not only is it harder to break a hardlink, but its
      content is tracked in git like a normal file.

      imagine a simple git repo that contains 2 links to a file, a symlink and a
      hardlink.  the original file that they both link to is not tracked by the git
      repo, because it is located in a different folder.  if someone using a different
      computer clones the repo and the original file doesn't exist, the hardlink will
      still be identical to the original file, but the symlink will be broken.

      #bash #git #symlink #hardlink #files

    file: "/Users/macbookpro/hero/tips/src/144641364200.md"
    lines:
    - favor hardlinks over symlinks, when possible.  for example, a symlink can break
    - for any number of reasons, not only is it harder to break a hardlink, but its
    - content is tracked in git like a normal file.
    - ''
    - imagine a simple git repo that contains 2 links to a file, a symlink and a
    - hardlink.  the original file that they both link to is not tracked by the git
    - repo, because it is located in a different folder.  if someone using a different
    - computer clones the repo and the original file doesn't exist, the hardlink will
    - still be identical to the original file, but the symlink will be broken.
    - ''
    - "#bash #git #symlink #hardlink #files"
    - ''
    tags:
    - bash
    - files
    - git
    - hardlink
    - symlink
    metadata: {}
    body:
    - favor hardlinks over symlinks, when possible.  for example, a symlink can break
    - for any number of reasons, not only is it harder to break a hardlink, but its
    - content is tracked in git like a normal file.
    - ''
    - imagine a simple git repo that contains 2 links to a file, a symlink and a
    - hardlink.  the original file that they both link to is not tracked by the git
    - repo, because it is located in a different folder.  if someone using a different
    - computer clones the repo and the original file doesn't exist, the hardlink will
    - still be identical to the original file, but the symlink will be broken.
    - ''
    - "#bash #git #symlink #hardlink #files"
    - ''
    name: favor hardlinks over symlinks, when possible.  for example, a symlink can
      break
  "/Users/macbookpro/hero/tips/src/144642214000.md": !ruby/object:CliTasks::Note
    data: |
      ignore or include hidden files when running a cmd on "everything"

      the difference between passing `.` and `*` to a command when you want to
      indicate the current directory

      * `.` will usually include dotfiles, since they exist in the current directory
      * `*`, on the other hand, will match all non-hidden files in the pwd.  if you
        are in a situation where you want to stick with `*`, but also want dotfiles
        included in the arg list, add `.*` like this: `* .*`.

      #bash #bash/file-patterns #bash/glob #bash/glob-pattern
      #zsh #zsh/file-patterns #zsh/glob #zsh/glob-pattern
      #files #files/glob-patterns #files/hidden-files
    file: "/Users/macbookpro/hero/tips/src/144642214000.md"
    lines:
    - ignore or include hidden files when running a cmd on "everything"
    - ''
    - the difference between passing `.` and `*` to a command when you want to
    - indicate the current directory
    - ''
    - "* `.` will usually include dotfiles, since they exist in the current directory"
    - "* `*`, on the other hand, will match all non-hidden files in the pwd.  if you"
    - "  are in a situation where you want to stick with `*`, but also want dotfiles"
    - "  included in the arg list, add `.*` like this: `* .*`."
    - ''
    - "#bash #bash/file-patterns #bash/glob #bash/glob-pattern"
    - "#zsh #zsh/file-patterns #zsh/glob #zsh/glob-pattern"
    - "#files #files/glob-patterns #files/hidden-files"
    tags:
    - bash
    - bash/file-patterns
    - bash/glob
    - bash/glob-pattern
    - files
    - files/glob-patterns
    - files/hidden-files
    - zsh
    - zsh/file-patterns
    - zsh/glob
    - zsh/glob-pattern
    metadata: {}
    body:
    - ignore or include hidden files when running a cmd on "everything"
    - ''
    - the difference between passing `.` and `*` to a command when you want to
    - indicate the current directory
    - ''
    - "* `.` will usually include dotfiles, since they exist in the current directory"
    - "* `*`, on the other hand, will match all non-hidden files in the pwd.  if you"
    - "  are in a situation where you want to stick with `*`, but also want dotfiles"
    - "  included in the arg list, add `.*` like this: `* .*`."
    - ''
    - "#bash #bash/file-patterns #bash/glob #bash/glob-pattern"
    - "#zsh #zsh/file-patterns #zsh/glob #zsh/glob-pattern"
    - "#files #files/glob-patterns #files/hidden-files"
    name: ignore or include hidden files when running a cmd on "everything"
  "/Users/macbookpro/hero/tips/src/144689013800.md": !ruby/object:CliTasks::Note
    data: |
      using symbolic-ref to make branch aliases is great because...

      1. it lets you access common branches with few keystrokes
      2. lets you have naming conventions to improve your workflow
      3. great for typing short checkout, cherry, cherry-pick, diff, etc. commands

      # Convention Example

      Whenever starting a feature branch, alias it as `feat`.
      Alias the branches that mirror remotes, with shorter names. `qa`, etc.

      #git #git/branch #git/symbolic-ref
    file: "/Users/macbookpro/hero/tips/src/144689013800.md"
    lines:
    - using symbolic-ref to make branch aliases is great because...
    - ''
    - 1. it lets you access common branches with few keystrokes
    - 2. lets you have naming conventions to improve your workflow
    - 3. great for typing short checkout, cherry, cherry-pick, diff, etc. commands
    - ''
    - "# Convention Example"
    - ''
    - Whenever starting a feature branch, alias it as `feat`.
    - Alias the branches that mirror remotes, with shorter names. `qa`, etc.
    - ''
    - "#git #git/branch #git/symbolic-ref"
    tags:
    - git
    - git/branch
    - git/symbolic-ref
    metadata: {}
    body:
    - using symbolic-ref to make branch aliases is great because...
    - ''
    - 1. it lets you access common branches with few keystrokes
    - 2. lets you have naming conventions to improve your workflow
    - 3. great for typing short checkout, cherry, cherry-pick, diff, etc. commands
    - ''
    - "# Convention Example"
    - ''
    - Whenever starting a feature branch, alias it as `feat`.
    - Alias the branches that mirror remotes, with shorter names. `qa`, etc.
    - ''
    - "#git #git/branch #git/symbolic-ref"
    name: using symbolic-ref to make branch aliases is great because...
  "/Users/macbookpro/hero/tips/src/144689089400.md": !ruby/object:CliTasks::Note
    data: |
      how to use `:il` so that it only looks in the current file

      write a shell script that will give u the first line number after the last
      require command

      #vim
    file: "/Users/macbookpro/hero/tips/src/144689089400.md"
    lines:
    - how to use `:il` so that it only looks in the current file
    - ''
    - write a shell script that will give u the first line number after the last
    - require command
    - ''
    - "#vim"
    tags:
    - vim
    metadata: {}
    body:
    - how to use `:il` so that it only looks in the current file
    - ''
    - write a shell script that will give u the first line number after the last
    - require command
    - ''
    - "#vim"
    name: how to use `:il` so that it only looks in the current file
  "/Users/macbookpro/hero/tips/src/144689089401.md": !ruby/object:CliTasks::Note
    data: |
      using a "start" file can drastically improve your vim speed

      create mappings to:

      - refresh the start file
      - change the current buffer to the start file

      #vim  #vim/start
    file: "/Users/macbookpro/hero/tips/src/144689089401.md"
    lines:
    - using a "start" file can drastically improve your vim speed
    - ''
    - 'create mappings to:'
    - ''
    - "- refresh the start file"
    - "- change the current buffer to the start file"
    - ''
    - "#vim  #vim/start"
    tags:
    - vim
    - vim/start
    metadata: {}
    body:
    - using a "start" file can drastically improve your vim speed
    - ''
    - 'create mappings to:'
    - ''
    - "- refresh the start file"
    - "- change the current buffer to the start file"
    - ''
    - "#vim  #vim/start"
    name: using a "start" file can drastically improve your vim speed
  "/Users/macbookpro/hero/tips/src/144689089402.md": !ruby/object:CliTasks::Note
    data: |
      one main reason i love `:b` is because it only requires the shortest uniq match
      of the filename to switch to that buffer

      (see: my vf cabbrev)

      #vim #vim/buffers #vim/commands
    file: "/Users/macbookpro/hero/tips/src/144689089402.md"
    lines:
    - one main reason i love `:b` is because it only requires the shortest uniq match
    - of the filename to switch to that buffer
    - ''
    - "(see: my vf cabbrev)"
    - ''
    - "#vim #vim/buffers #vim/commands"
    tags:
    - vim
    - vim/buffers
    - vim/commands
    metadata: {}
    body:
    - one main reason i love `:b` is because it only requires the shortest uniq match
    - of the filename to switch to that buffer
    - ''
    - "(see: my vf cabbrev)"
    - ''
    - "#vim #vim/buffers #vim/commands"
    name: one main reason i love `:b` is because it only requires the shortest uniq
      match
  "/Users/macbookpro/hero/tips/src/144692694700.md": !ruby/object:CliTasks::Note
    data: "#vim lets you define a leader key for a reason - avoid mappings that overwrite
      standard shortcuts, no matter how obscure they seem at the time"
    file: "/Users/macbookpro/hero/tips/src/144692694700.md"
    lines:
    - "#vim lets you define a leader key for a reason - avoid mappings that overwrite
      standard shortcuts, no matter how obscure they seem at the time"
    tags:
    - vim
    metadata: {}
    body:
    - "#vim lets you define a leader key for a reason - avoid mappings that overwrite
      standard shortcuts, no matter how obscure they seem at the time"
    name: "#vim lets you define a leader key for a reason - avoid mappings that overwrite
      standard shortcuts, no matter how obscure they seem at the time"
  "/Users/macbookpro/hero/tips/src/144752016100.md": !ruby/object:CliTasks::Note
    data: |+
      conveniently access functions in #vim using abbreviations and/or commands

      For example, I wrote a function that looks through v:oldfiles for a search
      pattern and opens the matches.  I gave the function some long, descriptive name,
      but I named the commands and abbreviations like this:

      ```
      command! -nargs=+ VsOldfile call VsplitMatchingOldfilePartialFilename(<f-args>)
      cabbrev vf VsOldfile
      ```

      This way, all I have to do is type `:vf<space>` and it expands into
      `:VsOldFile<space>` which will call my function when given a search pattern.

    file: "/Users/macbookpro/hero/tips/src/144752016100.md"
    lines:
    - 'conveniently access functions in #vim using abbreviations and/or commands'
    - ''
    - For example, I wrote a function that looks through v:oldfiles for a search
    - pattern and opens the matches.  I gave the function some long, descriptive name,
    - 'but I named the commands and abbreviations like this:'
    - ''
    - "```"
    - command! -nargs=+ VsOldfile call VsplitMatchingOldfilePartialFilename(<f-args>)
    - cabbrev vf VsOldfile
    - "```"
    - ''
    - This way, all I have to do is type `:vf<space>` and it expands into
    - "`:VsOldFile<space>` which will call my function when given a search pattern."
    - ''
    tags:
    - vim
    metadata: {}
    body:
    - 'conveniently access functions in #vim using abbreviations and/or commands'
    - ''
    - For example, I wrote a function that looks through v:oldfiles for a search
    - pattern and opens the matches.  I gave the function some long, descriptive name,
    - 'but I named the commands and abbreviations like this:'
    - ''
    - "```"
    - command! -nargs=+ VsOldfile call VsplitMatchingOldfilePartialFilename(<f-args>)
    - cabbrev vf VsOldfile
    - "```"
    - ''
    - This way, all I have to do is type `:vf<space>` and it expands into
    - "`:VsOldFile<space>` which will call my function when given a search pattern."
    - ''
    name: 'conveniently access functions in #vim using abbreviations and/or commands'
  "/Users/macbookpro/hero/tips/src/144769570700.md": !ruby/object:CliTasks::Note
    data: |
      delete file using its inode number

      sometimes a file is named in a way that it is hard to delete using the normal
      command-line.  to delete it, first find it's inode number, then use find to run
      rm on it.

      ```
      ls -il   # the first column is the inode number

      find . -inum "$INODE_GOES_HERE" -exec rm -i \{\} \;

      ```

      #unix #unix/rm #files
    file: "/Users/macbookpro/hero/tips/src/144769570700.md"
    lines:
    - delete file using its inode number
    - ''
    - sometimes a file is named in a way that it is hard to delete using the normal
    - command-line.  to delete it, first find it's inode number, then use find to
      run
    - rm on it.
    - ''
    - "```"
    - 'ls -il   # the first column is the inode number'
    - ''
    - find . -inum "$INODE_GOES_HERE" -exec rm -i \{\} \;
    - ''
    - "```"
    - ''
    - "#unix #unix/rm #files"
    tags:
    - files
    - unix
    - unix/rm
    metadata: {}
    body:
    - delete file using its inode number
    - ''
    - sometimes a file is named in a way that it is hard to delete using the normal
    - command-line.  to delete it, first find it's inode number, then use find to
      run
    - rm on it.
    - ''
    - "```"
    - 'ls -il   # the first column is the inode number'
    - ''
    - find . -inum "$INODE_GOES_HERE" -exec rm -i \{\} \;
    - ''
    - "```"
    - ''
    - "#unix #unix/rm #files"
    name: delete file using its inode number
  "/Users/macbookpro/hero/tips/src/144770572800.md": !ruby/object:CliTasks::Note
    data: |
      #idealism all commands should have allow their output to be filtered with a pattern (regex)
    file: "/Users/macbookpro/hero/tips/src/144770572800.md"
    lines:
    - "#idealism all commands should have allow their output to be filtered with a
      pattern (regex)"
    tags:
    - idealism
    metadata: {}
    body:
    - "#idealism all commands should have allow their output to be filtered with a
      pattern (regex)"
    name: "#idealism all commands should have allow their output to be filtered with
      a pattern (regex)"
  "/Users/macbookpro/hero/tips/src/144770572801.md": !ruby/object:CliTasks::Note
    data: |
      #tips/bash make shell commands for the sites you visit often, probably with search builtin, etc.
    file: "/Users/macbookpro/hero/tips/src/144770572801.md"
    lines:
    - "#tips/bash make shell commands for the sites you visit often, probably with
      search builtin, etc."
    tags:
    - tips/bash
    metadata: {}
    body:
    - "#tips/bash make shell commands for the sites you visit often, probably with
      search builtin, etc."
    name: "#tips/bash make shell commands for the sites you visit often, probably
      with search builtin, etc."
  "/Users/macbookpro/hero/tips/src/144788368100.md": !ruby/object:CliTasks::Note
    data: |
      # quickref: mastering tmux

      to master tmux, there are only a few things you need to learn.

      ## Contents

      * keyboard shortcuts
      * concepts (controlling tmux from the shell)
      * commands
          * `list-commands`
          * `list-keys`
          * `list-*`
          * `show-options`
          * `show-window-options`
          * `show-*`


      ## keyboard shortcuts

      The most important keyboard shortcut to learn is `<prefix>?`.  It is the default
      shortcut for showing you a list of every other keyboard shortcut.

      If I were to suggest any other shortcuts, they would probably be `<prefix>[`,
      `<prefix>]`, and `<prefix>=`.  These shortcuts are for switching into copy-mode and pasting what
      was last copied.  The last one, `<prefix>=`, shows you a list of all text that
      has been copied, and lets you choose the one to paste.

      ## concepts

      This next tip is probably the most powerful one.

      You can control tmux by running tmux commands from any shell prompt.  For
      example, let's say the current tmux window has 2 panes, split horizontally.  By
      default, the panes are equal in size.  However, let's assume that you want the
      bottom pane to only take up 5 rows.  If you move focus to the bottom pane, and
      you run the following shell command: `tmux resize-pane -y 5`, then tmux will
      know which pane you are in, and set that pane's height to 5 rows/lines.

      This same technique can by used to build all kinds of complex scripts, and it
      gives you an enormous amount of control over tmux.

      As a side note, this is possible, because all tmux panes set 2 environment
      variables:

      1. `TMUX` - the file that represents the tmux session
      2. `TMUX_PANE` - the id to use when having a tmux command target the current pane
        For example: `tmux resize-pane -y 5 -t $TMUX_PANE` is another way of running
        the same command as earlier.

      ## commands

      There are probably 4 commands that every tmuxu user should know:

      1. `list-commands` - lists every possible tmux command with all possible options
      2. `list-keys` - lists all configured keyboard shortcuts, the same thing as
         typing `<prefix>?` inside a tmux session
      3. `show-options` - lists all configurable tmux options
      4. `show-window-options` - lists all configurable tmux options that affect the
         current window.

      Learning all of these commands, and how to use them to manipulate tmux, will let
      you do anything you can imagine with tmux, as long as tmux is capable of doing
      it.

      #tmux
    file: "/Users/macbookpro/hero/tips/src/144788368100.md"
    lines:
    - "# quickref: mastering tmux"
    - ''
    - to master tmux, there are only a few things you need to learn.
    - ''
    - "## Contents"
    - ''
    - "* keyboard shortcuts"
    - "* concepts (controlling tmux from the shell)"
    - "* commands"
    - "    * `list-commands`"
    - "    * `list-keys`"
    - "    * `list-*`"
    - "    * `show-options`"
    - "    * `show-window-options`"
    - "    * `show-*`"
    - ''
    - ''
    - "## keyboard shortcuts"
    - ''
    - The most important keyboard shortcut to learn is `<prefix>?`.  It is the default
    - shortcut for showing you a list of every other keyboard shortcut.
    - ''
    - If I were to suggest any other shortcuts, they would probably be `<prefix>[`,
    - "`<prefix>]`, and `<prefix>=`.  These shortcuts are for switching into copy-mode
      and pasting what"
    - was last copied.  The last one, `<prefix>=`, shows you a list of all text that
    - has been copied, and lets you choose the one to paste.
    - ''
    - "## concepts"
    - ''
    - This next tip is probably the most powerful one.
    - ''
    - You can control tmux by running tmux commands from any shell prompt.  For
    - example, let's say the current tmux window has 2 panes, split horizontally.  By
    - default, the panes are equal in size.  However, let's assume that you want the
    - bottom pane to only take up 5 rows.  If you move focus to the bottom pane, and
    - 'you run the following shell command: `tmux resize-pane -y 5`, then tmux will'
    - know which pane you are in, and set that pane's height to 5 rows/lines.
    - ''
    - This same technique can by used to build all kinds of complex scripts, and it
    - gives you an enormous amount of control over tmux.
    - ''
    - As a side note, this is possible, because all tmux panes set 2 environment
    - 'variables:'
    - ''
    - 1. `TMUX` - the file that represents the tmux session
    - 2. `TMUX_PANE` - the id to use when having a tmux command target the current
      pane
    - "  For example: `tmux resize-pane -y 5 -t $TMUX_PANE` is another way of running"
    - "  the same command as earlier."
    - ''
    - "## commands"
    - ''
    - 'There are probably 4 commands that every tmuxu user should know:'
    - ''
    - 1. `list-commands` - lists every possible tmux command with all possible options
    - 2. `list-keys` - lists all configured keyboard shortcuts, the same thing as
    - "   typing `<prefix>?` inside a tmux session"
    - 3. `show-options` - lists all configurable tmux options
    - 4. `show-window-options` - lists all configurable tmux options that affect the
    - "   current window."
    - ''
    - Learning all of these commands, and how to use them to manipulate tmux, will
      let
    - you do anything you can imagine with tmux, as long as tmux is capable of doing
    - it.
    - ''
    - "#tmux"
    tags:
    - tmux
    metadata: {}
    body:
    - "# quickref: mastering tmux"
    - ''
    - to master tmux, there are only a few things you need to learn.
    - ''
    - "## Contents"
    - ''
    - "* keyboard shortcuts"
    - "* concepts (controlling tmux from the shell)"
    - "* commands"
    - "    * `list-commands`"
    - "    * `list-keys`"
    - "    * `list-*`"
    - "    * `show-options`"
    - "    * `show-window-options`"
    - "    * `show-*`"
    - ''
    - ''
    - "## keyboard shortcuts"
    - ''
    - The most important keyboard shortcut to learn is `<prefix>?`.  It is the default
    - shortcut for showing you a list of every other keyboard shortcut.
    - ''
    - If I were to suggest any other shortcuts, they would probably be `<prefix>[`,
    - "`<prefix>]`, and `<prefix>=`.  These shortcuts are for switching into copy-mode
      and pasting what"
    - was last copied.  The last one, `<prefix>=`, shows you a list of all text that
    - has been copied, and lets you choose the one to paste.
    - ''
    - "## concepts"
    - ''
    - This next tip is probably the most powerful one.
    - ''
    - You can control tmux by running tmux commands from any shell prompt.  For
    - example, let's say the current tmux window has 2 panes, split horizontally.  By
    - default, the panes are equal in size.  However, let's assume that you want the
    - bottom pane to only take up 5 rows.  If you move focus to the bottom pane, and
    - 'you run the following shell command: `tmux resize-pane -y 5`, then tmux will'
    - know which pane you are in, and set that pane's height to 5 rows/lines.
    - ''
    - This same technique can by used to build all kinds of complex scripts, and it
    - gives you an enormous amount of control over tmux.
    - ''
    - As a side note, this is possible, because all tmux panes set 2 environment
    - 'variables:'
    - ''
    - 1. `TMUX` - the file that represents the tmux session
    - 2. `TMUX_PANE` - the id to use when having a tmux command target the current
      pane
    - "  For example: `tmux resize-pane -y 5 -t $TMUX_PANE` is another way of running"
    - "  the same command as earlier."
    - ''
    - "## commands"
    - ''
    - 'There are probably 4 commands that every tmuxu user should know:'
    - ''
    - 1. `list-commands` - lists every possible tmux command with all possible options
    - 2. `list-keys` - lists all configured keyboard shortcuts, the same thing as
    - "   typing `<prefix>?` inside a tmux session"
    - 3. `show-options` - lists all configurable tmux options
    - 4. `show-window-options` - lists all configurable tmux options that affect the
    - "   current window."
    - ''
    - Learning all of these commands, and how to use them to manipulate tmux, will
      let
    - you do anything you can imagine with tmux, as long as tmux is capable of doing
    - it.
    - ''
    - "#tmux"
    name: "# quickref: mastering tmux"
tags:
  bash: []
  files: []
  git: []
  hardlink: []
  symlink: []
  bash/file-patterns: []
  bash/glob: []
  bash/glob-pattern: []
  files/glob-patterns: []
  files/hidden-files: []
  zsh: []
  zsh/file-patterns: []
  zsh/glob: []
  zsh/glob-pattern: []
  git/branch: []
  git/symbolic-ref: []
  vim: []
  vim/start: []
  vim/buffers: []
  vim/commands: []
  unix: []
  unix/rm: []
  idealism: []
  tips/bash: []
  tmux: []
